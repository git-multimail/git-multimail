#!/bin/sh

d=$(dirname "$0")

retcode=0
errors=
record_error () {
    errors="$errors $1"
    retcode=1
}

printf '%s' 'Python version: '
python2 --version
printf '%s' 'PEP8 version: '
pep8 --version
printf '%s' 'Git version: '
git --version
printf '%s' 'rstcheck version: '
rstcheck --version

echo

if ! "$d"/check-sign-off
then
    record_error sign-off
else
    echo "Each commit has a sign-off: PASS"
fi

rstcheck_file () {
    if ! rstcheck "$d"/../"$1" >$d/rstcheck.out 2>&1 ||
	test -s "$d"/rstcheck.out
    then
	cat "$d"/rstcheck.out
	record_error RST
    else
	echo "No RST error in $1: PASS"
    fi
}
rstcheck_file README.rst
rstcheck_file doc/gitolite.rst

# W503: line break before binary operator => could eventually be
# removed, but at a moment where there are less pending PRs.
#
# E402: module level import not at top of file => we need this in the
# tests.
#
# E501: line too long (... characters) => we don't have _very_ long
# lines, but we could get better.
#
# E123: closing bracket does not match indentation of opening bracket's line
# => not raised on all pep8 version, and really constraining. We can
# probably keep ignoring it forever.
pep8_file () {
    if ! pep8 "$d"/../"$1" --ignore=W503,E402,E501,E123
    then
	record_error PEP8
    else
	echo "No new PEP8 error in $1 found: PASS"
    fi
}
pep8_file git-multimail/git_multimail.py
pep8_file t/test-env

if ! "$d/test-email-content"
then
    record_error test-email-content
else
    echo "test-email-content: PASS"
fi

if ! "$d/test-env"
then
    record_error test-env
else
    echo "test-env: PASS"
fi

if [ -n "$errors" ]
then
    echo "Errors found in:$errors" >&2
fi

exit $retcode
