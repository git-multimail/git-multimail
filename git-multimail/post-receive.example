#! /usr/bin/env python

"""Example post-receive hook based on git-multimail.

The simplest way to use git-multimail is to use the script
git_multimail.py directly as a post-receive hook, and to configure it
using Git's configuration files and command-line parameters.  You can
also write your own Python wrapper for more advanced configurability,
using git_multimail.py as a Python module.

This script is a simple example of such a post-receive hook.  It is
intended to be customized before use; see the comments in the script
to help you get started.

Using git-multimail as a Python module as done here provides more
flexibility.  It has the following advantages:

* The tool's behavior can be customized using arbitrary Python code,
  without having to edit git_multimail.py.

* Configuration settings can be read from other sources; for example,
  user names and email addresses could be read from LDAP or from a
  database.  Or the settings can even be hardcoded in the importing
  Python script, if this is preferred.

This script is a very basic example of how to use git_multimail.py as
a module.  The comments below explain some of the points at which the
script's behavior could be changed or customized.

"""

import sys

# If necessary, add the path to the directory containing
# git_multimail.py to the Python path as follows.  (This is not
# necessary if git_multimail.py is in the same directory as this
# script):

#LIBDIR = 'path/to/directory/containing/module'
#sys.path.insert(0, LIBDIR)

import git_multimail

# It is possible to modify the output templates here; e.g.:

#git_multimail.FOOTER_TEMPLATE = """\
#
#-- \n\
#This email was generated by the wonderful git-multimail tool.
#"""


# Specify which "git config" section contains the configuration for
# git-multimail:
config = git_multimail.Config('multimailhook')

# Set some Git configuration variables. Equivalent to passing var=val
# to "git -c var=val" each time git is called, or to adding the
# configuration in .git/config (must come before instantiating the
# environment) :
#git_multimail.Config.add_config_parameters('multimailhook.commitEmailFormat=html')
#git_multimail.Config.add_config_parameters(('user.name=foo', 'user.email=foo@example.com'))

# Select the type of environment:
try:
    environment = git_multimail.GenericEnvironment(config=config)
    #environment = git_multimail.GitoliteEnvironment(config=config)
except git_multimail.ConfigurationException:
    sys.stderr.write('*** %s\n' % sys.exc_info()[1])
    sys.exit(1)


# Choose the method of sending emails based on the git config:
mailer = git_multimail.choose_mailer(config, environment)

# Alternatively, you may hardcode the mailer using code like one of
# the following:

# Use "/usr/sbin/sendmail -oi -t" to send emails.  The envelopesender
# argument is optional:
#mailer = git_multimail.SendMailer(
#    command=['/usr/sbin/sendmail', '-oi', '-t'],
#    envelopesender='git-repo@example.com',
#    )

# Use Python's smtplib to send emails.  Both arguments are required.
#mailer = git_multimail.SMTPMailer(
#    environment=environment,
#    envelopesender='git-repo@example.com',
#    # The smtpserver argument can also include a port number; e.g.,
#    #     smtpserver='mail.example.com:25'
#    smtpserver='mail.example.com',
#    )

# OutputMailer is intended only for testing; it writes the emails to
# the specified file stream.
#mailer = git_multimail.OutputMailer(sys.stdout)


# Read changes from stdin and send notification emails:
git_multimail.run_as_post_receive_hook(environment, mailer)
